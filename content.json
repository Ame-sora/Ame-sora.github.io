{"meta":{"title":"Ame__","subtitle":null,"description":"我可是高智能机器人！","author":"Ame__","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"测试","slug":"测试","date":"2020-08-10T13:04:31.000Z","updated":"2020-08-09T07:12:13.206Z","comments":true,"path":"2020/08/10/测试/","link":"","permalink":"/2020/08/10/测试/","excerpt":"","text":"$ My guiding star $ \\begin{eqnarray} \\nabla\\cdot\\vec{E} &=& \\frac{\\rho}{\\epsilon_0} \\\\ \\nabla\\cdot\\vec{B} &=& 0 \\\\ \\nabla\\times\\vec{E} &=& -\\frac{\\partial B}{\\partial t} \\\\ \\nabla\\times\\vec{B} &=& \\mu_0\\left(\\vec{J}+\\epsilon_0\\frac{\\partial E}{\\partial t} \\right) \\end{eqnarray}","categories":[{"name":"Oi","slug":"Oi","permalink":"/categories/Oi/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"/tags/杂项/"}],"keywords":[{"name":"Oi","slug":"Oi","permalink":"/categories/Oi/"}]},{"title":"数论","slug":"数论","date":"2020-08-08T22:01:45.000Z","updated":"2020-08-09T07:11:50.777Z","comments":true,"path":"2020/08/09/数论/","link":"","permalink":"/2020/08/09/数论/","excerpt":"","text":"整除复制粘贴来的定义：设a为非零自然数，b为整数.若存在一个整数q，使得b=a*q，那么可说b被a整除记为a|b，且b为a的倍数，a为b的因子​来一点性质?) 1.若有$a|b$，$b|c$，则有$a|c$ 2.$a|b$，$a|c$ &lt;==&gt; $a|(b x + c y)$ 3.设$m$ $≠ 0$,则有$a|b$ &lt;==&gt; $(m a)|(m b)$ 4.设有整数$x , y$,满足$ax+by=1$,且$a|n,b|n$,那么则有$(a*b)|n$ 5,若$b=q*d+c$,那么$d|b$的充分必要条件为$d|c$ 也没有题，就是一工具来用 同余定义:若$a,b$为两个整数，且它们的差$a-b$可被某个自然数$m$所整除，则称$a$就膜$m$来说同余于$b$,或者说$a$和$b$关于膜$m$同余，记为$a\\equiv b \\pmod{m}$ 你也可以转化一下变成$a-b=m*k$($k\\subseteq N$)​ 关于$a\\equiv b \\pmod{m}$有这么丶性质 1.自反性$a\\equiv a \\pmod{m}$ 2.对称性$a\\equiv b \\pmod{m}$则有$b\\equiv a \\pmod{m}$ 3.传递性$a\\equiv b \\pmod{m}$，$b\\equiv c \\pmod{m}$，则有$a\\equiv c \\pmod{m}$ 4.相加性$a\\equiv b \\pmod{m}$，则有$a+c\\equiv b+c \\pmod{m}$ 5.同乘性若$a\\equiv b \\pmod{m}$，则有$ac\\equiv bc \\pmod{m}$ ​ 若$a\\equiv b \\pmod{m}$，$c\\equiv d \\pmod{m}$，则有$ac\\equiv bd \\pmod{m}$ 6.同幂性$a\\equiv b \\pmod{m}$，则有$a^c\\equiv b^c \\pmod{m}$ 7.$ab mod k=(amodk)(bmodk)modk$ 8.若$amodp=x,amodq=x$,$p,q$互质 则有$amodp*q=x$ 最经典的利用还是辗转相除法了,欧几里得定理引定理：裴蜀定理若a,b是整数,且gcd(a,b)=c，那么对于任意的整数x,y,ax+by都一定是c的倍数，特别地，一定存在整数x,y，使ax+by=d成立。 推论:a,b互质的充要条件是存在整数x,y使ax+by=1 原理:$gcd(x , y)=gcd(x , y -x)$ $\\begin{aligned}\\sum_{i=1}^n\\sum_{j=1}^n\\gcd(i,j)\\end{aligned}$ =$\\begin{aligned}\\sum_{i=1}^n\\sum_{j=1}^n\\sum_{d|i,j}d[gcd(\\frac{i}{d},\\frac{j}{d})==1]\\end{aligned}$ $Code$ inline int gcd(int x , int y){ return y == 0 ? x : gcd(y , x % y); } 假如你听懂了这个东西并且会写for循环，你可以做掉这个题UVA11417 GCD $Code$ #include&lt;bits/stdc++.h&gt; #define LL long long using namespace std; template &lt;typename T&gt; void read(T &amp; t) { t = 0;int f = 1;char ch = getchar(); while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;){if(ch == &#39;-&#39;)f =- 1;ch = getchar();} do{t = t * 10 + ch - &#39;0&#39;;ch = getchar();}while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;);t *= f; } inline LL gcd(LL x , LL y){ return y == 0 ? x : gcd(y , x % y); } int n; inline int Ame_(){ while(cin &gt;&gt; n){ if(!n){ return 0; } LL ans = 0; for(int i = 1;i &lt;= n;i ++){ for(int j = i + 1;j &lt;= n;j ++){ ans += gcd(i , j); } } printf(&quot;%lld\\n&quot; , ans); } return 0; } int Ame__ = Ame_(); int main(){;} 这是一个复杂度为 $O(n^2)$ 假如你会一，，的莫比乌斯反演你可以做掉这个题UVA11424 GCD - Extreme(I) 如何去推柿子呢 \\sum_{i=1}^{n}\\sum_{j=i+1}^{n}\\gcd(i,j)你会发现在计算j时重复计算了i的那么我们考虑先将其看作单独的i，j，随后将重复部分减去即可 $\\begin{aligned}\\sum_{i = 1}^n\\sum_{j = 1}^n\\gcd(i, j)= \\sum_{d = 1}^nd\\sum_{i = 1}^n\\sum_{j = 1}^n[\\gcd(i, j) = d]=\\sum_{d = 1}^nd\\sum_{x=1}^{\\left\\lfloor\\frac n d\\right\\rfloor}\\mu(p)\\left\\lfloor\\frac n {dp}\\right\\rfloor\\left\\lfloor\\frac n {dp}\\right\\rfloor\\end{aligned}=\\begin{aligned}\\sum_{Q = 1}^n\\sum_{d|Q}d*\\mu(\\frac Q{d})\\left\\lfloor\\frac n {Q}\\right\\rfloor^2\\end{aligned}=\\begin{aligned}\\sum_{Q = 1}^n\\varphi(Q)\\left\\lfloor\\frac n {Q}\\right\\rfloor^2\\end{aligned}$ 到了这里,我们发现对于$[gcd(i,j)=1]$我们可以根据莫比乌斯函数的定义$\\begin{aligned}\\sum_{d\\mid n}\\mu(d) =[n=1]\\end{aligned}$来进行替换，即 $\\begin{aligned}\\sum_{d=1}^n\\sum_{i=1}^\\frac{n}{d}\\sum_{j=1}^\\frac{n}{d}\\sum_{p\\mid i,j}\\mu(p)\\end{aligned}$ 我们可以按照套路将$p$提前$\\begin{aligned}\\sum_{d=1}^n\\sum_{p=1}^\\frac{n}{d}\\mu(p)\\sum_{i=1}^\\frac{n}{d}[p\\mid i]\\sum_{j=1}^\\frac{n}{d}[p\\mid j]\\end{aligned}$ 整除分块非常清晰的证明请见dalao证明整除分块 常见卷积 $σ(n)$：约数和函数，表示n的全部约数和 $\\mu*id_0=\\epsilon$ $\\varphi*id_0=id_1$ $\\mu*id_1=\\varphi$ $id_0*id_1=σ$然后你会发现他还有一个题UVA11426 拿行李（极限版） GCD - Extreme (II)你发现他的n更大了，然后你会惊奇的发现如果用上面的柿子可以过掉这个题，然后你会发现还有一个题SP3871 GCDEX - GCD Extreme,一模一样这样你就有了三倍的经验 不对，是四倍P1390公约数求和,不对是五倍，还有一个阉割版本P2398 GCD SUM对于这个题P3327 [SDOI2015]约数个数和就是多处理了一个m，而且数据范围很小筛$\\mu$就可以了 $Code$ #include&lt;bits/stdc++.h&gt; #define LL long long using namespace std; template &lt;typename T&gt; void read(T &amp; t) { t = 0;int f = 1;char ch = getchar(); while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;){if(ch == &#39;-&#39;)f =- 1;ch = getchar();} do{t = t * 10 + ch - &#39;0&#39;;ch = getchar();}while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;);t *= f; } const int kato = 1e5 + 1; bool ispri[kato]; int n; LL prime[kato] , phi[kato] , sum[kato] , cnt; inline void get_phi(){ for(int i = 2;i &lt;= kato;i ++){ if(!ispri[i]){ prime[++ cnt] = i; phi[i] = i - 1; } for(int j = 1;j &lt;= cnt &amp;&amp; (i * prime[j] &lt;= kato);j ++){ ispri[i * prime[j]] = 1; if(i % prime[j] == 0){ phi[i * prime[j]] = phi[i] * prime[j]; break; } else{ phi[i * prime[j]] = phi[i] * (prime[j] - 1); } } } for(int i = 1;i &lt;= kato;i ++){ sum[i] = sum[i - 1] + phi[i]; } } inline int Ame_(){ phi[1] = 1 , ispri[1] = 1; read(n); get_phi(); LL ans = 0; for(int l = 1 , r;l &lt;= n;l = r + 1){ r = n / (n / l); ans += (sum[r] - sum[l - 1]) * (n / l) * (n / l); } printf(&quot;%lld\\n&quot; , ans); return 0; } int Ame__ = Ame_(); int main(){;} 阉割版代码复杂度约为 $O(n + \\sqrt n)$ $Code$ #include&lt;bits/stdc++.h&gt; #define LL long long using namespace std; template &lt;typename T&gt; void read(T &amp; t) { t = 0;int f = 1;char ch = getchar(); while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;){if(ch == &#39;-&#39;)f =- 1;ch = getchar();} do{t = t * 10 + ch - &#39;0&#39;;ch = getchar();}while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;);t *= f; } const int kato = 4e6 + 1; bool ispri[kato]; LL n; LL prime[kato] , phi[kato] , sum[kato] , cnt; inline void get_phi(){ for(int i = 2;i &lt;= kato;i ++){ if(!ispri[i]){ prime[++ cnt] = i; phi[i] = i - 1; } for(int j = 1;j &lt;= cnt &amp;&amp; (i * prime[j] &lt;= kato);j ++){ ispri[i * prime[j]] = 1; if(i % prime[j] == 0){ phi[i * prime[j]] = phi[i] * prime[j]; break; } else{ phi[i * prime[j]] = phi[i] * phi[prime[j]]; } } } for(int i = 1;i &lt;= kato;i ++){ // if(i&lt;=10) cerr&lt;&lt;phi[i]&lt;&lt;&quot;\\n&quot;; sum[i] = sum[i - 1] + phi[i]; } } inline int Ame_(){ phi[1] = 1 , ispri[1] = 1; get_phi(); while(cin &gt;&gt; n){ if(!n){ return 0; } LL ans = 0; for(LL l = 1 , r;l &lt;= n;l = r + 1){ r = n / (n / l); ans += (sum[r] - sum[l - 1]) * (n / l) * (n / l); } ans -= n * (n + 1) / 2; ans /= 2; printf(&quot;%lld\\n&quot; , ans); } return 0; } int Ame__ = Ame_(); signed main(){;} 非阉割版代码，注意卡精度复杂度约为 $O(n + T\\sqrt n)$ 现在你学会了gcd让我们来试一试用他做题吧 P2257 YY的GCD 推柿子 题目所给为$\\begin{aligned}\\sum_{i=1}^n\\sum_{j=1}^m[gcd(x,y)\\in prime]\\end{aligned}$ $\\begin{aligned}=\\sum_{p\\in prime}\\sum_{i=1}^n\\sum_{j=1}^m[gcd(x,y)=p]\\end{aligned}$ $\\begin{aligned}=\\sum_{p\\in prime}\\sum_{i=1}^n\\sum_{j=1}^m[gcd(\\frac{x}{p},\\frac{y}{p})=1]\\end{aligned}$ $\\begin{aligned}=\\sum_{p\\in prime}\\sum_{i=1}^\\frac{n}{p}\\sum_{j=1}^\\frac{m}{p}[gcd(x,y)=1]\\end{aligned}$ 到了这里,我们发现对于$[gcd(i,j)=1]$我们可以根据莫比乌斯函数的定义$\\begin{aligned}\\sum_{d\\mid n}\\mu(d) =[n=1]\\end{aligned}$来进行替换，即 $\\begin{aligned}\\sum_{p\\in prime}\\sum_{i=1}^\\frac{n}{p}\\sum_{j=1}^\\frac{m}{p}\\sum_{d\\mid i,j}\\mu(d)\\end{aligned}$ 然后重点来了，你粗略地看着个柿子可以看为$\\begin{aligned}\\sum_{p}\\sum_{i}\\sum_{j}\\sum_{d=1}\\mu(d)[d\\mid i][d\\mid j]\\end{aligned}$,其中对$\\mu(d)$有影响的为$p$可以提到$i$前面，$[d\\mid i]$,$[d\\mid j]$同理可得,则有下一步柿子 $\\begin{aligned}\\sum_{p\\in prime}\\sum_{d=1}^\\frac{n}{p}\\mu(d)\\sum_{i=1}^\\frac{n}{p}[d\\mid i]\\sum_{j=1}^\\frac{m}{p}[d\\mid j]\\end{aligned}$ 然后用之前所学过的整除分块对$[d\\mid i]$, $[d\\mid j]$处理一下 $\\begin{aligned}\\sum_{p\\in prime}\\sum_{d=1}^\\frac{n}{p}\\mu(d)\\left \\lfloor \\frac{n}{dp} \\right \\rfloor\\left \\lfloor \\frac{m}{dp} \\right \\rfloor\\end{aligned}$ 将dp用k更换之后有$\\begin{aligned}\\sum_{k=1}^n\\sum_{p\\in prime}\\mu(d)\\left \\lfloor \\frac{n}{k} \\right \\rfloor\\left \\lfloor \\frac{m}{k} \\right \\rfloor\\end{aligned}$ 最后在筛的时候维护一个前缀和即可 $Code$ #include&lt;bits/stdc++.h&gt; #define LL long long using namespace std; template &lt;typename T&gt; void read(T &amp; t){ t = 0;int f = 1;char ch = getchar(); while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;){if(ch == &#39;-&#39;)f =- 1;ch = getchar();} do{t = t * 10 + ch - &#39;0&#39;;ch = getchar();}while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;);t *= f; } const int kato = 1e7 + 10; int prime[kato &gt;&gt; 1] , cnt , t; int mu[kato] , num[kato]; bool ispri[kato]; inline int my_swap(int &amp;x , int &amp;y){ return x ^= y ^= x ^= y ; } inline void pri(){ for(int i = 2;i &lt;= kato - 10;i ++){ if(!ispri[i]){ prime[++ cnt] = i; mu[i] =- 1; } for(int j = 1;j &lt;= cnt &amp;&amp; (i * prime[j] &lt;= kato - 10);j ++){ if(i * prime[j] &lt;= kato - 10){ ispri[i * prime[j]] = 1; } if(i % prime[j] == 0){ break; } else{ mu[i * prime[j]] =- mu[i]; } } } for(int i = 1;i &lt;= cnt;i ++){ int res = 1; for(int j = prime[i];j &lt;= kato - 1;j += prime[i] , res ++){ num[j] += mu[res]; } } for(int i = 2;i &lt;= kato - 10;i ++){ num[i] += num[i - 1]; } } inline int Ame_(){ mu[1] = 1; pri(); read(t); for(int l , r , n , m; t --&gt; 0 ;){ read(n);read(m); LL ans = 0; if(n &gt; m){ my_swap(n , m); } for(l = 1 , r;l &lt;= n;l = r + 1){ r = min(n / (n / l) , m / (m / l)); ans += 1LL * (num[r] - num[l - 1]) * (n / l) * (m / l); } printf(&quot;%lld\\n&quot; , ans); } return 0; } int Ame__ = Ame_(); int main(){;} EXGCD对于等式 $ax+by=gcd(a,b)$ 一定存在整数解 则可用$exgcd$来求x的最小非负数解 $\\left\\{ \\begin{array}{lrc} ax+by=gcd(a,b)\\ bx’+(a\\%b)y’=gcd(b,a\\%b)\\\\a\\%b=a-b*\\lfloor\\frac ab\\rfloor\\\\gcd(a,b)=gcd(b,a\\%b) \\end{array} \\right.\\Rightarrow\\left\\{\\begin{array}{lrc} x=y’\\\\y=x’-y’\\lfloor\\frac ab\\rfloor \\end{array} \\right.$ 之后令$g=gcd(a,b)$则 $lcm(a,b)=a*b/g$又 $ax+lcm(a,b)+by-lcm(a,b)=c$ 故有 $a(x+b/g)+b(y-a/g)=c$由此可得，$x$ 加上或减去任意倍数的 $b/gcd(a,b)$ 后均有对应的y的解令 $t=b/g$， $(x\\%t+t)\\%t$ 就是x的最小非负解 $Code$ inline void exgcd(LL a , LL b , LL &amp;x , LL &amp;y){ if(b == 0){ x = 1; y = 0; return; } exgcd(b , a % b , y , x); y -= a / b * x; } 同余方程对于同余式 $ax≡b(modp)$ ,可以转化为 $ax+kp=b$ 就可以应用$exgcd$求了 特殊的，对于同余式 $a≡1(modp)$的一个解是 a 在模 p 意义下的逆元 P1082同余方程 $Code$ #include&lt;bits/stdc++.h&gt; #define LL long long using namespace std; template &lt;typename T&gt; void read(T &amp; t) { t = 0;int f = 1;char ch = getchar(); while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;){if(ch == &#39;-&#39;)f =- 1;ch = getchar();} do{t = t * 10 + ch - &#39;0&#39;;ch = getchar();}while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;);t *= f; } int x , y , a , b; inline void exgcd(int a , int b , int &amp;x , int &amp;y){ if(!b){ x = 1; y = 0; return; } exgcd(b , a % b , y , x); y -= a / b * x; } inline int Ame_(){ read(a);read(b); exgcd(a , b , x , y); printf(&quot;%d&quot;, (x % b + b) % b); return 0; } int Ame__ = Ame_(); int main(){;} 欧拉函数小于或等于n的正整数中与n互质的数的数目 通式有$\\varphi(n)=n\\prod\\limits_{i=1}^c(1-\\dfrac 1{p_i})$(其中$p1, p2……pn$为$x$的所有质因数，x是不为0的整数) 若n是质数p的k次幂，则有 证明的话因为比$n$小的正整数有$p^k-1$个。其中可被$p$所整除的数均可表示为$p*t(t=1,2,3…p^{k-1} -1 )$,即共有$p^{k -1}-1$个这样的数可被p整除，从而不与$p^k$互质 则有$\\varphi(n)=p^k -1-(p^{k-1}-1)=(p-1)p^k-1$ 如果还是不懂举个栗子比如$12=223那么φ（12）=φ（43）=φ（2^23^1）=（2^2-2^1）*（3^1-3^0）=4$ 由于欧拉函数为积性函数，则有 同时特殊的当n为奇质数时，，这东西不用我证明了吧 当n为质数时则有 证明 由唯一分解定理， 则有， 随便带个数进去计算就显而易见了 例如 同时可以引出欧拉定理 对任何两个互质的正整数a, m(m&gt;=2)有 还有一个结论，有个毒瘤题用到了$\\varphi(i\\times j) = \\huge{\\left(\\frac{\\varphi(i) \\times \\varphi(j) \\times \\gcd(i,j)}{\\varphi(\\gcd(i,j))}\\right)}$ 一般没有裸题，板子有线性筛P3383 【模板】线性筛素数这题别告诉我你没过 #include&lt;bits/stdc++.h&gt; #define LL long long using namespace std; template &lt;typename T&gt; void read(T &amp; t) { t = 0;int f = 1;char ch = getchar(); while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;){if(ch == &#39;-&#39;)f =- 1;ch = getchar();} do{t = t * 10 + ch - &#39;0&#39;;ch = getchar();}while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;);t *= f; } const int kato = 1e8 + 1; int prime[kato] , n , cnt , q; bool ispri[kato]; inline void pri(){ for(int i = 2;i &lt;= n;i ++){ if(!ispri[i]){ prime[++ cnt] = i; } for(int j = 1;j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n;j ++){ ispri[i * prime[j]] = 1; if(i % prime[j] == 0){ break; } } } } inline int Ame_(){ read(n);read(q); ispri[1] = 1; pri(); for(int k; q --&gt; 0 ;){ read(k); printf(&quot;%d\\n&quot; , prime[k]); } return 0; } int Ame__ = Ame_(); int main(){;} 同时你也可以用欧拉筛去筛选莫比乌斯函数$\\mu(n)$和欧拉函数$\\varphi(n)$ $Code$ inline void pri(){ for(int i = 2;i &lt;= N;i ++){ if(!ispri[i]){ prime[++ cnt] = i; phi[i] = i - 1; mu[i] =- 1; } for(int j = 1;j &lt;= cnt &amp;&amp; (i * prime[j] &lt;= N);j ++){ ispri[i*prime[j]] = true; if(i % prime[j]==0){ phi[i * prime[j]] = phi[i] * prime[j]; break; } else{ phi[i * prime[j]] = phi[i] * (prime[j] - 1) , mu[i * prime[j]] =- mu[i]; } } } 写一起去了对于杜教筛只需要维护一个前缀和就好，课下可以写一下 上次考试的那个题的正解就是基于此思想上的筛法 中国剩余定理用于求解形如 $\\begin{cases}x\\equiv a_1\\pmod{m_1}\\\\x\\equiv a_2\\pmod{m_2}\\.……..\\\\x\\equiv a_k\\pmod{m_k}\\end{cases}$ 的同余方程组的定理，其中有$m_1,m_2,m_3…….m_k$两两互质的整数,我的所要求的为x的最小负整数解 解法：假设$M=\\begin{matrix} \\prod_{i=1}^k m_i \\end{matrix}$ , $M_i=\\frac{M}{m_i}$ , $M_it_i\\equiv 1 \\pmod{m_i}$其中有其中$1≤i≤k1$显然，$M$表示所有方程组的模的乘积；$M_i$​表示除第$i$个方程外，其余所有方程的模的乘积；$t_i$​则为$M_i$​的逆元我们可以求出其中一解为我们可以构造出一个解$x=\\begin{matrix} \\sum_{i=1}^k a_iM_it_i \\end{matrix}$对于任意的解$x_0$可表示为$x+kM$则可求出最小正整数解为$x_{min}=x_0$%M 例题P1495模板 $Code$ #include&lt;bits/stdc++.h&gt; #define LL long long using namespace std; template &lt;typename T&gt; void read(T &amp; t){ t = 0;int f = 1;char ch = getchar(); while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;){if(ch == &#39;-&#39;)f =- 1;ch = getchar();} do{t = t * 10 + ch - &#39;0&#39;;ch = getchar();}while(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;);t *= f; } LL n , a[16] , m[16] , Mi[16] , mul = 1 , X; inline void exgcd(LL a , LL b , LL &amp;x , LL &amp;y){ if(b == 0){ x = 1; y = 0; return; } exgcd(b , a % b , x , y); y -= (a / b) * x; return; } inline int Ame_(){ read(n); for(int i = 1;i &lt;= n;i ++){ int M; read(M); m[i] = M , mul *= M; read(a[i]); } for(int i = 1;i &lt;= n;i ++){ Mi[i] = mul / m[i]; LL x = 0 , y = 0; exgcd(Mi[i] , m[i] , x , y); X += a[i] * Mi[i] * (x &lt; 0 ? x + m[i] : x); } printf(&quot;%lld&quot;,X % mul); return 0; } int Ame__ = Ame_(); int main(){;}","categories":[{"name":"Oi","slug":"Oi","permalink":"/categories/Oi/"}],"tags":[{"name":"Oi","slug":"Oi","permalink":"/tags/Oi/"},{"name":"数学","slug":"数学","permalink":"/tags/数学/"}],"keywords":[{"name":"Oi","slug":"Oi","permalink":"/categories/Oi/"}]}]}